# Basic Workflow Examples

This guide demonstrates common workflows for using loco-mcp-server with Claude Code Agent to generate loco-rs applications.

## Prerequisites

1. **Install loco-mcp-server** (see README.md)
2. **Configure Claude Code with MCP Server**:

   Add the loco MCP server to your Claude Code configuration:

   **Method 1: Using Claude Code Settings**
   - Open Claude Code settings
   - Navigate to "MCP Servers"
   - Add server with configuration:
   ```json
   {
     "name": "loco",
     "description": "Loco framework code generation server",
     "command": "loco-mcp-server",
     "args": []
   }
   ```

   **Method 2: Configuration File**
   ```json
   {
     "mcpServers": {
       "loco": {
         "command": "loco-mcp-server",
         "args": []
       }
     }
   }
   ```

   Restart Claude Code after configuration.

3. **Create a loco-rs project**:
   ```bash
   cargo install loco-cli
   loco new my_app --starter saas
   cd my_app
   ```

4. **Verify Setup**:
   - The loco tools should appear in Claude Code's tools panel
   - Test with: *"Create a simple test model"*

## Workflow 1: Create a Basic Blog System

### Step 1: Generate User Model

**Prompt to Claude Code:**
> "Create a user model with email, username, password hash, and created_at fields"

**Expected Result:**
```python
# Generated by loco-mcp-server
{
  "success": true,
  "created_files": [
    {"path": "src/models/user.rs", "type": "model", "size_bytes": 245},
    {"path": "migration/src/m_20240101_120000_create_users.rs", "type": "migration", "size_bytes": 189}
  ],
  "modified_files": [],
  "errors": []
}
```

**Generated Model (`src/models/user.rs`):**
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub email: String,
    pub username: String,
    pub password_hash: String,
    pub created_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}
```

### Step 2: Generate Blog Post Scaffold

**Prompt to Claude Code:**
> "Generate a complete CRUD scaffold for blog posts with title, content, published status, and author relationship"

**Expected Result:**
```python
{
  "success": true,
  "created_files": [
    {"path": "src/models/blog_post.rs", "type": "model", "size_bytes": 312},
    {"path": "migration/src/m_20240101_120100_create_blog_posts.rs", "type": "migration", "size_bytes": 234},
    {"path": "src/controllers/blog_posts.rs", "type": "controller", "size_bytes": 1876},
    {"path": "src/views/blog_posts/list.html.tera", "type": "view", "size_bytes": 1234},
    {"path": "src/views/blog_posts/show.html.tera", "type": "view", "size_bytes": 892},
    {"path": "src/views/blog_posts/form.html.tera", "type": "view", "size_bytes": 567}
  ],
  "modified_files": [
    {"path": "src/routes/mod.rs", "type": "route"}
  ],
  "errors": []
}
```

### Step 3: Generate Comment Model

**Prompt to Claude Code:**
> "Create a comment model with content, blog post relationship, and user relationship"

### Step 4: Generate Controllers for Existing Models

**Prompt to Claude Code:**
> "Add a controller for the user model with index, show, and edit actions"

## Workflow 2: Build an E-commerce Product System

### Step 1: Product Model with Variants

**Prompt to Claude Code:**
> "Create a product model with name, description, price, sku, and inventory count fields"

**Follow-up:**
> "Add a product variant model with product relationship, size, color, and additional price"

### Step 2: Category System

**Prompt to Claude Code:**
> "Generate a category model with name, description, and parent category support"

**Follow-up:**
> "Create a product category relationship model to link products to categories"

### Step 3: Order Management

**Prompt to Claude Code:**
> "Generate an order model with user relationship, total amount, status, and created_at"

**Follow-up:**
> "Add order items model to link products to orders with quantity and price"

## Workflow 3: API-First Development

### Step 1: Generate API Models

**Prompt to Claude Code:**
> "Create an API key model with key string, name, permissions JSON, and expiration date"

**Follow-up:**
> "Generate API-only scaffold for user management (no views, just JSON endpoints)"

### Step 2: Authentication System

**Prompt to Claude Code:**
> "Create a session model with user relationship, token, expires_at, and is_active"

**Follow-up:**
> "Generate API-only controller for authentication with login and logout endpoints"

## Workflow 4: Content Management System

### Step 1: Content Structure

**Prompt to Claude Code:**
> "Create a page model with title, slug, content text, published status, and metadata JSON"

**Follow-up:**
> "Add a media asset model with file path, MIME type, size, and alt text"

### Step 2: User Roles and Permissions

**Prompt to Claude Code:**
> "Generate a role model with name and permissions array"

**Follow-up:**
> "Create user role assignment model to link users to roles"

## Advanced Workflows

### Custom Field Types

**Prompt to Claude Code:**
> "Create a custom field definition model with field type, validation rules, and default value"

**Follow-up:**
> "Add custom field values model to store dynamic field values for any entity"

### Multi-tenant Support

**Prompt to Claude Code:**
> "Add a tenant model with name, domain, and settings JSON"

**Follow-up:**
> "Update existing models to include tenant relationship for multi-tenancy"

## Error Handling Examples

### Validation Errors

**Invalid Prompt:**
> "Create a model with 123invalid name"

**Response:**
```python
{
  "success": false,
  "created_files": [],
  "modified_files": [],
  "errors": [
    "Model name '123invalid' is invalid. Must start with a letter and contain only letters, numbers, and underscores."
  ],
  "suggestions": [
    "Use snake_case naming like 'user_profile' or 'blog_post'",
    "Start with a letter and use underscores for spaces"
  ]
}
```

### Project Detection Errors

**Invalid Context:**
> Running commands outside a loco-rs project

**Response:**
```python
{
  "success": false,
  "errors": [
    "Not a valid loco-rs project directory. Missing src/models/ directory."
  ],
  "suggestions": [
    "Navigate to a valid loco-rs project directory",
    "Create a new loco-rs project with 'loco new my_app'",
    "Run 'loco doctor' to check project structure"
  ]
}
```

## Performance Optimization

### Template Caching

The system automatically caches frequently used templates:

```python
# Check cache performance
metrics = loco_bindings.get_performance_metrics()
print(f"Cache hit rate: {metrics['hit_rate']:.1%}")
print(f"Average response time: {metrics['avg_duration_ms']:.2f}ms")
```

### Batch Operations

For multiple related models:

**Prompt to Claude Code:**
> "Generate a complete user management system with profiles, roles, and permissions all at once"

This will:
1. Create user model with basic fields
2. Generate user profile model with one-to-one relationship
3. Create role and permission models
4. Set up relationship models
5. Generate controllers for all models
6. Create appropriate views

## Best Practices

### Model Design

1. **Use snake_case for model names**: `blog_post`, `user_profile`
2. **Choose appropriate field types**: `text` for long content, `string` for short text
3. **Add constraints**: Use `:unique` for email fields, `:nullable` for optional fields
4. **Consider relationships**: Add foreign keys for related data

### Workflow Tips

1. **Start simple**: Create basic models first, then add relationships
2. **Generate in logical order**: Models first, then controllers, then views
3. **Test incrementally**: Run migrations and test each model as you create it
4. **Use descriptive names**: Clear model and field names make the code maintainable

### Error Prevention

1. **Validate project structure**: Ensure you're in a loco-rs project
2. **Check naming conventions**: Use valid snake_case names
3. **Verify field types**: Use supported field types and proper constraints
4. **Test after generation**: Run migrations and test generated code

## Integration with Claude Code

### Natural Language Patterns

Effective prompts for Claude Code:

- **Model Creation**: "Create a [model_name] model with [field1:type], [field2:type:constraint]"
- **Scaffold Generation**: "Generate a complete CRUD scaffold for [model_name]"
- **Controller Addition**: "Add a controller for existing [model_name] with [actions]"
- **API Development**: "Create API-only scaffold for [model_name]"

### Context Management

Claude Code maintains context of your project structure:

- Remembers existing models
- Understands relationships
- Suggests appropriate field types
- Validates naming conventions

### Iterative Development

Build complex applications iteratively:

1. Start with core entities
2. Add relationships and constraints
3. Generate controllers and views
4. Customize templates as needed
5. Add business logic

## Troubleshooting

### Common Issues

**Build failures after generation:**
```bash
# Check for compilation errors
cargo check

# Run migrations
cargo loco db migrate

# Check generated code
cat src/models/your_model.rs
```

**Missing relationships:**
```bash
# Verify foreign key constraints
cargo loco db status

# Check migration files
ls migration/src/
```

**Template errors:**
```bash
# Check view templates
ls src/views/your_model/

# Verify template syntax
cat src/views/your_model/list.html.tera
```

### Getting Help

- Check generated files for syntax errors
- Verify loco-rs project structure
- Run `loco doctor` for project health check
- Review error messages for specific guidance

## Next Steps

After mastering these basic workflows:

1. **Customize templates**: Modify generated templates for your needs
2. **Add business logic**: Implement custom methods in models and controllers
3. **Set up authentication**: Add user authentication and authorization
4. **Configure database**: Set up production database connections
5. **Deploy application**: Deploy your loco-rs application to production